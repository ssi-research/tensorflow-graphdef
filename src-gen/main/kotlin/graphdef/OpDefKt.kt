//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: graphdef/op_def.proto

package graphdef;

@kotlin.jvm.JvmName("-initializeopDef")
public inline fun opDef(block: graphdef.OpDefKt.Dsl.() -> kotlin.Unit): graphdef.OpDef =
  graphdef.OpDefKt.Dsl._create(graphdef.OpDef.newBuilder()).apply { block() }._build()
public object OpDefKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: graphdef.OpDef.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: graphdef.OpDef.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): graphdef.OpDef = _builder.build()

    /**
     * <pre>
     * Op names starting with an underscore are reserved for internal use.
     * Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9&gt;_]*".
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public var name: kotlin.String
      @JvmName("getName")
      get() = _builder.getName()
      @JvmName("setName")
      set(value) {
        _builder.setName(value)
      }
    /**
     * <pre>
     * Op names starting with an underscore are reserved for internal use.
     * Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9&gt;_]*".
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public fun clearName() {
      _builder.clearName()
    }

    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class InputArgProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     */
     public val inputArg: com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>
      @kotlin.jvm.JvmSynthetic
      get() = com.google.protobuf.kotlin.DslList(
        _builder.getInputArgList()
      )
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     * @param value The inputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addInputArg")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>.add(value: graphdef.OpDef.ArgDef) {
      _builder.addInputArg(value)
    }
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     * @param value The inputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignInputArg")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>.plusAssign(value: graphdef.OpDef.ArgDef) {
      add(value)
    }
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     * @param values The inputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAllInputArg")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>.addAll(values: kotlin.collections.Iterable<graphdef.OpDef.ArgDef>) {
      _builder.addAllInputArg(values)
    }
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     * @param values The inputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAllInputArg")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>.plusAssign(values: kotlin.collections.Iterable<graphdef.OpDef.ArgDef>) {
      addAll(values)
    }
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     * @param index The index to set the value at.
     * @param value The inputArg to set.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("setInputArg")
    public operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>.set(index: kotlin.Int, value: graphdef.OpDef.ArgDef) {
      _builder.setInputArg(index, value)
    }
    /**
     * <pre>
     * Description of the input(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef input_arg = 2;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("clearInputArg")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, InputArgProxy>.clear() {
      _builder.clearInputArg()
    }


    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class OutputArgProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     */
     public val outputArg: com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>
      @kotlin.jvm.JvmSynthetic
      get() = com.google.protobuf.kotlin.DslList(
        _builder.getOutputArgList()
      )
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     * @param value The outputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addOutputArg")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>.add(value: graphdef.OpDef.ArgDef) {
      _builder.addOutputArg(value)
    }
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     * @param value The outputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignOutputArg")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>.plusAssign(value: graphdef.OpDef.ArgDef) {
      add(value)
    }
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     * @param values The outputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAllOutputArg")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>.addAll(values: kotlin.collections.Iterable<graphdef.OpDef.ArgDef>) {
      _builder.addAllOutputArg(values)
    }
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     * @param values The outputArg to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAllOutputArg")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>.plusAssign(values: kotlin.collections.Iterable<graphdef.OpDef.ArgDef>) {
      addAll(values)
    }
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     * @param index The index to set the value at.
     * @param value The outputArg to set.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("setOutputArg")
    public operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>.set(index: kotlin.Int, value: graphdef.OpDef.ArgDef) {
      _builder.setOutputArg(index, value)
    }
    /**
     * <pre>
     * Description of the output(s).
     * </pre>
     *
     * <code>repeated .uni_model_proto.OpDef.ArgDef output_arg = 3;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("clearOutputArg")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.ArgDef, OutputArgProxy>.clear() {
      _builder.clearOutputArg()
    }


    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class ControlOutputProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     * @return A list containing the controlOutput.
     */
    public val controlOutput: com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>
      @kotlin.jvm.JvmSynthetic
      get() = com.google.protobuf.kotlin.DslList(
        _builder.getControlOutputList()
      )
    /**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     * @param value The controlOutput to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addControlOutput")
    public fun com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>.add(value: kotlin.String) {
      _builder.addControlOutput(value)
    }
    /**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     * @param value The controlOutput to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignControlOutput")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>.plusAssign(value: kotlin.String) {
      add(value)
    }
    /**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     * @param values The controlOutput to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAllControlOutput")
    public fun com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>.addAll(values: kotlin.collections.Iterable<kotlin.String>) {
      _builder.addAllControlOutput(values)
    }
    /**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     * @param values The controlOutput to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAllControlOutput")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>.plusAssign(values: kotlin.collections.Iterable<kotlin.String>) {
      addAll(values)
    }
    /**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     * @param index The index to set the value at.
     * @param value The controlOutput to set.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("setControlOutput")
    public operator fun com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>.set(index: kotlin.Int, value: kotlin.String) {
      _builder.setControlOutput(index, value)
    }/**
     * <pre>
     * Named control outputs for this operation. Useful only for composite
     * operations (i.e. functions) which want to name different control outputs.
     * </pre>
     *
     * <code>repeated string control_output = 20;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("clearControlOutput")
    public fun com.google.protobuf.kotlin.DslList<kotlin.String, ControlOutputProxy>.clear() {
      _builder.clearControlOutput()
    }
    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class AttrProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     */
     public val attr: com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>
      @kotlin.jvm.JvmSynthetic
      get() = com.google.protobuf.kotlin.DslList(
        _builder.getAttrList()
      )
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     * @param value The attr to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAttr")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>.add(value: graphdef.OpDef.AttrDef) {
      _builder.addAttr(value)
    }
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     * @param value The attr to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAttr")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>.plusAssign(value: graphdef.OpDef.AttrDef) {
      add(value)
    }
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     * @param values The attr to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAllAttr")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>.addAll(values: kotlin.collections.Iterable<graphdef.OpDef.AttrDef>) {
      _builder.addAllAttr(values)
    }
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     * @param values The attr to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAllAttr")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>.plusAssign(values: kotlin.collections.Iterable<graphdef.OpDef.AttrDef>) {
      addAll(values)
    }
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     * @param index The index to set the value at.
     * @param value The attr to set.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("setAttr")
    public operator fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>.set(index: kotlin.Int, value: graphdef.OpDef.AttrDef) {
      _builder.setAttr(index, value)
    }
    /**
     * <code>repeated .uni_model_proto.OpDef.AttrDef attr = 4;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("clearAttr")
    public fun com.google.protobuf.kotlin.DslList<graphdef.OpDef.AttrDef, AttrProxy>.clear() {
      _builder.clearAttr()
    }


    /**
     * <pre>
     * Optional deprecation based on GraphDef versions.
     * </pre>
     *
     * <code>.uni_model_proto.OpDeprecation deprecation = 8;</code>
     */
    public var deprecation: graphdef.OpDeprecation
      @JvmName("getDeprecation")
      get() = _builder.getDeprecation()
      @JvmName("setDeprecation")
      set(value) {
        _builder.setDeprecation(value)
      }
    /**
     * <pre>
     * Optional deprecation based on GraphDef versions.
     * </pre>
     *
     * <code>.uni_model_proto.OpDeprecation deprecation = 8;</code>
     */
    public fun clearDeprecation() {
      _builder.clearDeprecation()
    }
    /**
     * <pre>
     * Optional deprecation based on GraphDef versions.
     * </pre>
     *
     * <code>.uni_model_proto.OpDeprecation deprecation = 8;</code>
     * @return Whether the deprecation field is set.
     */
    public fun hasDeprecation(): kotlin.Boolean {
      return _builder.hasDeprecation()
    }

    /**
     * <pre>
     * One-line human-readable description of what the Op does.
     * </pre>
     *
     * <code>string summary = 5;</code>
     */
    public var summary: kotlin.String
      @JvmName("getSummary")
      get() = _builder.getSummary()
      @JvmName("setSummary")
      set(value) {
        _builder.setSummary(value)
      }
    /**
     * <pre>
     * One-line human-readable description of what the Op does.
     * </pre>
     *
     * <code>string summary = 5;</code>
     */
    public fun clearSummary() {
      _builder.clearSummary()
    }

    /**
     * <pre>
     * Additional, longer human-readable description of what the Op does.
     * </pre>
     *
     * <code>string description = 6;</code>
     */
    public var description: kotlin.String
      @JvmName("getDescription")
      get() = _builder.getDescription()
      @JvmName("setDescription")
      set(value) {
        _builder.setDescription(value)
      }
    /**
     * <pre>
     * Additional, longer human-readable description of what the Op does.
     * </pre>
     *
     * <code>string description = 6;</code>
     */
    public fun clearDescription() {
      _builder.clearDescription()
    }

    /**
     * <pre>
     * True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
     * </pre>
     *
     * <code>bool is_commutative = 18;</code>
     */
    public var isCommutative: kotlin.Boolean
      @JvmName("getIsCommutative")
      get() = _builder.getIsCommutative()
      @JvmName("setIsCommutative")
      set(value) {
        _builder.setIsCommutative(value)
      }
    /**
     * <pre>
     * True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
     * </pre>
     *
     * <code>bool is_commutative = 18;</code>
     */
    public fun clearIsCommutative() {
      _builder.clearIsCommutative()
    }

    /**
     * <pre>
     * If is_aggregate is true, then this operation accepts N &gt;= 2
     * inputs and produces 1 output all of the same type.  Should be
     * associative and commutative, and produce output with the same
     * shape as the input.  The optimizer may replace an aggregate op
     * taking input from multiple devices with a tree of aggregate ops
     * that aggregate locally within each device (and possibly within
     * groups of nearby devices) before communicating.
     * TODO(josh11b): Implement that optimization.
     * </pre>
     *
     * <code>bool is_aggregate = 16;</code>
     */
    public var isAggregate: kotlin.Boolean
      @JvmName("getIsAggregate")
      get() = _builder.getIsAggregate()
      @JvmName("setIsAggregate")
      set(value) {
        _builder.setIsAggregate(value)
      }
    /**
     * <pre>
     * If is_aggregate is true, then this operation accepts N &gt;= 2
     * inputs and produces 1 output all of the same type.  Should be
     * associative and commutative, and produce output with the same
     * shape as the input.  The optimizer may replace an aggregate op
     * taking input from multiple devices with a tree of aggregate ops
     * that aggregate locally within each device (and possibly within
     * groups of nearby devices) before communicating.
     * TODO(josh11b): Implement that optimization.
     * </pre>
     *
     * <code>bool is_aggregate = 16;</code>
     */
    public fun clearIsAggregate() {
      _builder.clearIsAggregate()
    }

    /**
     * <pre>
     * Ops are marked as stateful if their behavior depends on some state beyond
     * their input tensors (e.g. variable reading op) or if they have
     * a side-effect (e.g. printing or asserting ops). Equivalently, stateless ops
     * must always produce the same output for the same input and have
     * no side-effects.
     * By default Ops may be moved between devices.  Stateful ops should
     * either not be moved, or should only be moved if that state can also
     * be moved (e.g. via some sort of save / restore).
     * Stateful ops are guaranteed to never be optimized away by Common
     * Subexpression Elimination (CSE).
     * </pre>
     *
     * <code>bool is_stateful = 17;</code>
     */
    public var isStateful: kotlin.Boolean
      @JvmName("getIsStateful")
      get() = _builder.getIsStateful()
      @JvmName("setIsStateful")
      set(value) {
        _builder.setIsStateful(value)
      }
    /**
     * <pre>
     * Ops are marked as stateful if their behavior depends on some state beyond
     * their input tensors (e.g. variable reading op) or if they have
     * a side-effect (e.g. printing or asserting ops). Equivalently, stateless ops
     * must always produce the same output for the same input and have
     * no side-effects.
     * By default Ops may be moved between devices.  Stateful ops should
     * either not be moved, or should only be moved if that state can also
     * be moved (e.g. via some sort of save / restore).
     * Stateful ops are guaranteed to never be optimized away by Common
     * Subexpression Elimination (CSE).
     * </pre>
     *
     * <code>bool is_stateful = 17;</code>
     */
    public fun clearIsStateful() {
      _builder.clearIsStateful()
    }

    /**
     * <pre>
     * By default, all inputs to an Op must be initialized Tensors.  Ops
     * that may initialize tensors for the first time should set this
     * field to true, to allow the Op to take an uninitialized Tensor as
     * input.
     * </pre>
     *
     * <code>bool allows_uninitialized_input = 19;</code>
     */
    public var allowsUninitializedInput: kotlin.Boolean
      @JvmName("getAllowsUninitializedInput")
      get() = _builder.getAllowsUninitializedInput()
      @JvmName("setAllowsUninitializedInput")
      set(value) {
        _builder.setAllowsUninitializedInput(value)
      }
    /**
     * <pre>
     * By default, all inputs to an Op must be initialized Tensors.  Ops
     * that may initialize tensors for the first time should set this
     * field to true, to allow the Op to take an uninitialized Tensor as
     * input.
     * </pre>
     *
     * <code>bool allows_uninitialized_input = 19;</code>
     */
    public fun clearAllowsUninitializedInput() {
      _builder.clearAllowsUninitializedInput()
    }

    /**
     * <pre>
     * Indicates whether the op implementation uses distributed communication.
     * If True, the op is allowed to return errors for network disconnection and
     * trigger TF network failure handling logics.
     * </pre>
     *
     * <code>bool is_distributed_communication = 21;</code>
     */
    public var isDistributedCommunication: kotlin.Boolean
      @JvmName("getIsDistributedCommunication")
      get() = _builder.getIsDistributedCommunication()
      @JvmName("setIsDistributedCommunication")
      set(value) {
        _builder.setIsDistributedCommunication(value)
      }
    /**
     * <pre>
     * Indicates whether the op implementation uses distributed communication.
     * If True, the op is allowed to return errors for network disconnection and
     * trigger TF network failure handling logics.
     * </pre>
     *
     * <code>bool is_distributed_communication = 21;</code>
     */
    public fun clearIsDistributedCommunication() {
      _builder.clearIsDistributedCommunication()
    }
  }
  @kotlin.jvm.JvmName("-initializeargDef")
  public inline fun argDef(block: graphdef.OpDefKt.ArgDefKt.Dsl.() -> kotlin.Unit): graphdef.OpDef.ArgDef =
    graphdef.OpDefKt.ArgDefKt.Dsl._create(graphdef.OpDef.ArgDef.newBuilder()).apply { block() }._build()
  public object ArgDefKt {
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    @com.google.protobuf.kotlin.ProtoDslMarker
    public class Dsl private constructor(
      private val _builder: graphdef.OpDef.ArgDef.Builder
    ) {
      public companion object {
        @kotlin.jvm.JvmSynthetic
        @kotlin.PublishedApi
        internal fun _create(builder: graphdef.OpDef.ArgDef.Builder): Dsl = Dsl(builder)
      }

      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _build(): graphdef.OpDef.ArgDef = _builder.build()

      /**
       * <pre>
       * Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public var name: kotlin.String
        @JvmName("getName")
        get() = _builder.getName()
        @JvmName("setName")
        set(value) {
          _builder.setName(value)
        }
      /**
       * <pre>
       * Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public fun clearName() {
        _builder.clearName()
      }

      /**
       * <pre>
       * Human readable description.
       * </pre>
       *
       * <code>string description = 2;</code>
       */
      public var description: kotlin.String
        @JvmName("getDescription")
        get() = _builder.getDescription()
        @JvmName("setDescription")
        set(value) {
          _builder.setDescription(value)
        }
      /**
       * <pre>
       * Human readable description.
       * </pre>
       *
       * <code>string description = 2;</code>
       */
      public fun clearDescription() {
        _builder.clearDescription()
      }

      /**
       * <pre>
       * Describes the type of one or more tensors that are accepted/produced
       * by this input/output arg.  The only legal combinations are:
       * * For a single tensor: either the "type" field is set or the
       *   "type_attr" field is set to the name of an attr with type "type".
       * * For a sequence of tensors with the same type: the "number_attr"
       *   field will be set to the name of an attr with type "int", and
       *   either the "type" or "type_attr" field will be set as for
       *   single tensors.
       * * For a sequence of tensors, the "type_list_attr" field will be set
       *   to the name of an attr with type "list(type)".
       * </pre>
       *
       * <code>.uni_model_proto.DataType type = 3;</code>
       */
      public var type: graphdef.DataType
        @JvmName("getType")
        get() = _builder.getType()
        @JvmName("setType")
        set(value) {
          _builder.setType(value)
        }
      /**
       * <pre>
       * Describes the type of one or more tensors that are accepted/produced
       * by this input/output arg.  The only legal combinations are:
       * * For a single tensor: either the "type" field is set or the
       *   "type_attr" field is set to the name of an attr with type "type".
       * * For a sequence of tensors with the same type: the "number_attr"
       *   field will be set to the name of an attr with type "int", and
       *   either the "type" or "type_attr" field will be set as for
       *   single tensors.
       * * For a sequence of tensors, the "type_list_attr" field will be set
       *   to the name of an attr with type "list(type)".
       * </pre>
       *
       * <code>.uni_model_proto.DataType type = 3;</code>
       */
      public fun clearType() {
        _builder.clearType()
      }

      /**
       * <pre>
       * if specified, attr must have type "type"
       * </pre>
       *
       * <code>string type_attr = 4;</code>
       */
      public var typeAttr: kotlin.String
        @JvmName("getTypeAttr")
        get() = _builder.getTypeAttr()
        @JvmName("setTypeAttr")
        set(value) {
          _builder.setTypeAttr(value)
        }
      /**
       * <pre>
       * if specified, attr must have type "type"
       * </pre>
       *
       * <code>string type_attr = 4;</code>
       */
      public fun clearTypeAttr() {
        _builder.clearTypeAttr()
      }

      /**
       * <pre>
       * if specified, attr must have type "int"
       * </pre>
       *
       * <code>string number_attr = 5;</code>
       */
      public var numberAttr: kotlin.String
        @JvmName("getNumberAttr")
        get() = _builder.getNumberAttr()
        @JvmName("setNumberAttr")
        set(value) {
          _builder.setNumberAttr(value)
        }
      /**
       * <pre>
       * if specified, attr must have type "int"
       * </pre>
       *
       * <code>string number_attr = 5;</code>
       */
      public fun clearNumberAttr() {
        _builder.clearNumberAttr()
      }

      /**
       * <pre>
       * If specified, attr must have type "list(type)", and none of
       * type, type_attr, and number_attr may be specified.
       * </pre>
       *
       * <code>string type_list_attr = 6;</code>
       */
      public var typeListAttr: kotlin.String
        @JvmName("getTypeListAttr")
        get() = _builder.getTypeListAttr()
        @JvmName("setTypeListAttr")
        set(value) {
          _builder.setTypeListAttr(value)
        }
      /**
       * <pre>
       * If specified, attr must have type "list(type)", and none of
       * type, type_attr, and number_attr may be specified.
       * </pre>
       *
       * <code>string type_list_attr = 6;</code>
       */
      public fun clearTypeListAttr() {
        _builder.clearTypeListAttr()
      }

      /**
       * An uninstantiable, behaviorless type to represent the field in
       * generics.
       */
      @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
      public class HandleDataProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       */
       public val handleData: com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>
        @kotlin.jvm.JvmSynthetic
        get() = com.google.protobuf.kotlin.DslList(
          _builder.getHandleDataList()
        )
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       * @param value The handleData to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addHandleData")
      public fun com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>.add(value: graphdef.ResourceHandleProto.DtypeAndShape) {
        _builder.addHandleData(value)
      }
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       * @param value The handleData to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignHandleData")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>.plusAssign(value: graphdef.ResourceHandleProto.DtypeAndShape) {
        add(value)
      }
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       * @param values The handleData to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addAllHandleData")
      public fun com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>.addAll(values: kotlin.collections.Iterable<graphdef.ResourceHandleProto.DtypeAndShape>) {
        _builder.addAllHandleData(values)
      }
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       * @param values The handleData to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignAllHandleData")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>.plusAssign(values: kotlin.collections.Iterable<graphdef.ResourceHandleProto.DtypeAndShape>) {
        addAll(values)
      }
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       * @param index The index to set the value at.
       * @param value The handleData to set.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("setHandleData")
      public operator fun com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>.set(index: kotlin.Int, value: graphdef.ResourceHandleProto.DtypeAndShape) {
        _builder.setHandleData(index, value)
      }
      /**
       * <pre>
       * The handle data for resource inputs.
       * </pre>
       *
       * <code>repeated .uni_model_proto.ResourceHandleProto.DtypeAndShape handle_data = 7;</code>
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("clearHandleData")
      public fun com.google.protobuf.kotlin.DslList<graphdef.ResourceHandleProto.DtypeAndShape, HandleDataProxy>.clear() {
        _builder.clearHandleData()
      }


      /**
       * <pre>
       * For inputs: if true, the inputs are required to be refs.
       *   By default, inputs can be either refs or non-refs.
       * For outputs: if true, outputs are refs, otherwise they are not.
       * </pre>
       *
       * <code>bool is_ref = 16;</code>
       */
      public var isRef: kotlin.Boolean
        @JvmName("getIsRef")
        get() = _builder.getIsRef()
        @JvmName("setIsRef")
        set(value) {
          _builder.setIsRef(value)
        }
      /**
       * <pre>
       * For inputs: if true, the inputs are required to be refs.
       *   By default, inputs can be either refs or non-refs.
       * For outputs: if true, outputs are refs, otherwise they are not.
       * </pre>
       *
       * <code>bool is_ref = 16;</code>
       */
      public fun clearIsRef() {
        _builder.clearIsRef()
      }

      /**
       * <pre>
       * Experimental. Full type declaration for this argument.
       * The full type specification combines type, type_attr, type_list_attr,
       * etc. into a unified representation.
       * This declaration may contain non-concrete types (for example,
       * Tensor&lt;TypeVar&lt;'T'&gt;&gt; is a valid type declaration.
       * Note: this is a transient field. The long-term aim is to represent the
       * entire OpDef as a single type: a callable. In that context, this field is
       * just the type of a single argument.
       * </pre>
       *
       * <code>.uni_model_proto.FullTypeDef experimental_full_type = 17;</code>
       */
      public var experimentalFullType: graphdef.FullTypeDef
        @JvmName("getExperimentalFullType")
        get() = _builder.getExperimentalFullType()
        @JvmName("setExperimentalFullType")
        set(value) {
          _builder.setExperimentalFullType(value)
        }
      /**
       * <pre>
       * Experimental. Full type declaration for this argument.
       * The full type specification combines type, type_attr, type_list_attr,
       * etc. into a unified representation.
       * This declaration may contain non-concrete types (for example,
       * Tensor&lt;TypeVar&lt;'T'&gt;&gt; is a valid type declaration.
       * Note: this is a transient field. The long-term aim is to represent the
       * entire OpDef as a single type: a callable. In that context, this field is
       * just the type of a single argument.
       * </pre>
       *
       * <code>.uni_model_proto.FullTypeDef experimental_full_type = 17;</code>
       */
      public fun clearExperimentalFullType() {
        _builder.clearExperimentalFullType()
      }
      /**
       * <pre>
       * Experimental. Full type declaration for this argument.
       * The full type specification combines type, type_attr, type_list_attr,
       * etc. into a unified representation.
       * This declaration may contain non-concrete types (for example,
       * Tensor&lt;TypeVar&lt;'T'&gt;&gt; is a valid type declaration.
       * Note: this is a transient field. The long-term aim is to represent the
       * entire OpDef as a single type: a callable. In that context, this field is
       * just the type of a single argument.
       * </pre>
       *
       * <code>.uni_model_proto.FullTypeDef experimental_full_type = 17;</code>
       * @return Whether the experimentalFullType field is set.
       */
      public fun hasExperimentalFullType(): kotlin.Boolean {
        return _builder.hasExperimentalFullType()
      }
    }
  }
  @kotlin.jvm.JvmName("-initializeattrDef")
  public inline fun attrDef(block: graphdef.OpDefKt.AttrDefKt.Dsl.() -> kotlin.Unit): graphdef.OpDef.AttrDef =
    graphdef.OpDefKt.AttrDefKt.Dsl._create(graphdef.OpDef.AttrDef.newBuilder()).apply { block() }._build()
  public object AttrDefKt {
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    @com.google.protobuf.kotlin.ProtoDslMarker
    public class Dsl private constructor(
      private val _builder: graphdef.OpDef.AttrDef.Builder
    ) {
      public companion object {
        @kotlin.jvm.JvmSynthetic
        @kotlin.PublishedApi
        internal fun _create(builder: graphdef.OpDef.AttrDef.Builder): Dsl = Dsl(builder)
      }

      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _build(): graphdef.OpDef.AttrDef = _builder.build()

      /**
       * <pre>
       * A descriptive name for the argument.  May be used, e.g. by the
       * Python client, as a keyword argument name, and so should match
       * the regexp "[a-z][a-z0-9_]+".
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public var name: kotlin.String
        @JvmName("getName")
        get() = _builder.getName()
        @JvmName("setName")
        set(value) {
          _builder.setName(value)
        }
      /**
       * <pre>
       * A descriptive name for the argument.  May be used, e.g. by the
       * Python client, as a keyword argument name, and so should match
       * the regexp "[a-z][a-z0-9_]+".
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public fun clearName() {
        _builder.clearName()
      }

      /**
       * <pre>
       * One of the type names from attr_value.proto ("string", "list(string)",
       * "int", etc.).
       * </pre>
       *
       * <code>string type = 2;</code>
       */
      public var type: kotlin.String
        @JvmName("getType")
        get() = _builder.getType()
        @JvmName("setType")
        set(value) {
          _builder.setType(value)
        }
      /**
       * <pre>
       * One of the type names from attr_value.proto ("string", "list(string)",
       * "int", etc.).
       * </pre>
       *
       * <code>string type = 2;</code>
       */
      public fun clearType() {
        _builder.clearType()
      }

      /**
       * <pre>
       * A reasonable default for this attribute if the user does not supply
       * a value.  If not specified, the user must supply a value.
       * </pre>
       *
       * <code>.uni_model_proto.AttrValue default_value = 3;</code>
       */
      public var defaultValue: graphdef.AttrValue
        @JvmName("getDefaultValue")
        get() = _builder.getDefaultValue()
        @JvmName("setDefaultValue")
        set(value) {
          _builder.setDefaultValue(value)
        }
      /**
       * <pre>
       * A reasonable default for this attribute if the user does not supply
       * a value.  If not specified, the user must supply a value.
       * </pre>
       *
       * <code>.uni_model_proto.AttrValue default_value = 3;</code>
       */
      public fun clearDefaultValue() {
        _builder.clearDefaultValue()
      }
      /**
       * <pre>
       * A reasonable default for this attribute if the user does not supply
       * a value.  If not specified, the user must supply a value.
       * </pre>
       *
       * <code>.uni_model_proto.AttrValue default_value = 3;</code>
       * @return Whether the defaultValue field is set.
       */
      public fun hasDefaultValue(): kotlin.Boolean {
        return _builder.hasDefaultValue()
      }

      /**
       * <pre>
       * Human-readable description.
       * </pre>
       *
       * <code>string description = 4;</code>
       */
      public var description: kotlin.String
        @JvmName("getDescription")
        get() = _builder.getDescription()
        @JvmName("setDescription")
        set(value) {
          _builder.setDescription(value)
        }
      /**
       * <pre>
       * Human-readable description.
       * </pre>
       *
       * <code>string description = 4;</code>
       */
      public fun clearDescription() {
        _builder.clearDescription()
      }

      /**
       * <pre>
       * For type == "int", this is a minimum value.  For "list(___)"
       * types, this is the minimum length.
       * </pre>
       *
       * <code>bool has_minimum = 5;</code>
       */
      public var hasMinimum: kotlin.Boolean
        @JvmName("getHasMinimum")
        get() = _builder.getHasMinimum()
        @JvmName("setHasMinimum")
        set(value) {
          _builder.setHasMinimum(value)
        }
      /**
       * <pre>
       * For type == "int", this is a minimum value.  For "list(___)"
       * types, this is the minimum length.
       * </pre>
       *
       * <code>bool has_minimum = 5;</code>
       */
      public fun clearHasMinimum() {
        _builder.clearHasMinimum()
      }

      /**
       * <code>int64 minimum = 6;</code>
       */
      public var minimum: kotlin.Long
        @JvmName("getMinimum")
        get() = _builder.getMinimum()
        @JvmName("setMinimum")
        set(value) {
          _builder.setMinimum(value)
        }
      /**
       * <code>int64 minimum = 6;</code>
       */
      public fun clearMinimum() {
        _builder.clearMinimum()
      }

      /**
       * <pre>
       * The set of allowed values.  Has type that is the "list" version
       * of the "type" field above (uses the "list" field of AttrValue).
       * If type == "type" or "list(type)" above, then the "type" field
       * of "allowed_values.list" has the set of allowed DataTypes.
       * If type == "string" or "list(string)", then the "s" field of
       * "allowed_values.list" has the set of allowed strings.
       * </pre>
       *
       * <code>.uni_model_proto.AttrValue allowed_values = 7;</code>
       */
      public var allowedValues: graphdef.AttrValue
        @JvmName("getAllowedValues")
        get() = _builder.getAllowedValues()
        @JvmName("setAllowedValues")
        set(value) {
          _builder.setAllowedValues(value)
        }
      /**
       * <pre>
       * The set of allowed values.  Has type that is the "list" version
       * of the "type" field above (uses the "list" field of AttrValue).
       * If type == "type" or "list(type)" above, then the "type" field
       * of "allowed_values.list" has the set of allowed DataTypes.
       * If type == "string" or "list(string)", then the "s" field of
       * "allowed_values.list" has the set of allowed strings.
       * </pre>
       *
       * <code>.uni_model_proto.AttrValue allowed_values = 7;</code>
       */
      public fun clearAllowedValues() {
        _builder.clearAllowedValues()
      }
      /**
       * <pre>
       * The set of allowed values.  Has type that is the "list" version
       * of the "type" field above (uses the "list" field of AttrValue).
       * If type == "type" or "list(type)" above, then the "type" field
       * of "allowed_values.list" has the set of allowed DataTypes.
       * If type == "string" or "list(string)", then the "s" field of
       * "allowed_values.list" has the set of allowed strings.
       * </pre>
       *
       * <code>.uni_model_proto.AttrValue allowed_values = 7;</code>
       * @return Whether the allowedValues field is set.
       */
      public fun hasAllowedValues(): kotlin.Boolean {
        return _builder.hasAllowedValues()
      }
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun graphdef.OpDef.copy(block: graphdef.OpDefKt.Dsl.() -> kotlin.Unit): graphdef.OpDef =
  graphdef.OpDefKt.Dsl._create(this.toBuilder()).apply { block() }._build()

@kotlin.jvm.JvmSynthetic
public inline fun graphdef.OpDef.ArgDef.copy(block: graphdef.OpDefKt.ArgDefKt.Dsl.() -> kotlin.Unit): graphdef.OpDef.ArgDef =
  graphdef.OpDefKt.ArgDefKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val graphdef.OpDef.ArgDefOrBuilder.experimentalFullTypeOrNull: graphdef.FullTypeDef?
  get() = if (hasExperimentalFullType()) getExperimentalFullType() else null

@kotlin.jvm.JvmSynthetic
public inline fun graphdef.OpDef.AttrDef.copy(block: graphdef.OpDefKt.AttrDefKt.Dsl.() -> kotlin.Unit): graphdef.OpDef.AttrDef =
  graphdef.OpDefKt.AttrDefKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val graphdef.OpDef.AttrDefOrBuilder.defaultValueOrNull: graphdef.AttrValue?
  get() = if (hasDefaultValue()) getDefaultValue() else null

public val graphdef.OpDef.AttrDefOrBuilder.allowedValuesOrNull: graphdef.AttrValue?
  get() = if (hasAllowedValues()) getAllowedValues() else null

public val graphdef.OpDefOrBuilder.deprecationOrNull: graphdef.OpDeprecation?
  get() = if (hasDeprecation()) getDeprecation() else null

